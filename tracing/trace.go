package tracing

import (
	"context"
	"fmt"
	"time"

	"github.com/opentracing/opentracing-go"

	"github.com/reddit/baseplate.go/randbp"
	"github.com/reddit/baseplate.go/timebp"
)

// Well-known (special) span tag keys
const (
	TagKeyClient      = "client"
	TagKeyEndpoint    = "endpoint"
	TagKeySuccess     = "success"
	TagKeyPeerService = "peer.service"
)

// FlagMask values.
//
// Reference: https://github.com/reddit/baseplate.py/blob/1ca8488bcd42c8786e6a3db35b2a99517fd07a99/baseplate/observers/tracing.py#L60-L64
const (
	// When set, this trace passes all samplers.
	FlagMaskDebug int64 = 1
)

const (
	counterKeyPrefix   = "counter."
	baseplateComponent = "baseplate"
)

type trace struct {
	tracer opentracing.Tracer

	name     string
	traceID  string
	spanID   string
	parentID string
	sampled  bool
	flags    int64

	timeAnnotationReceiveKey string
	timeAnnotationSendKey    string
	start                    time.Time
	stop                     time.Time

	counters map[string]float64
	tags     map[string]string
}

func (t *trace) internalTracer() *Tracer {
	if t == nil {
		return nil
	}
	if tracer, ok := t.tracer.(*Tracer); ok && tracer != nil {
		return tracer
	}
	return nil
}

func newTrace(tracer *Tracer, name string) *trace {
	var (
		otTracer        opentracing.Tracer
		traceID, spanID string
	)
	if tracer == nil {
		otTracer = opentracing.GlobalTracer()
	
		// opentracing.Tracer is an interface that has only StartSpan, Inject, and Extract methods.
		// This function expects a *tracing.Tracer, but the global opentracing.Tracer may not be one.
		// That's why it's relying on the globalTracer: even if the opentracing.GlobalTracer() has been overridden,
		// the IDs generated by baseplate will still conform to the specified configuration.
		traceID = globalTracer.newTraceID()
		spanID = globalTracer.newSpanID()
	} else {
		otTracer = tracer
		traceID = tracer.newTraceID()
		spanID = tracer.newSpanID()
	}
	return &trace{
		tracer: otTracer,

		name:    name,
		traceID: traceID,
		spanID:  spanID,
		start:   time.Now(),

		counters: make(map[string]float64),
		tags: map[string]string{
			ZipkinBinaryAnnotationKeyComponent: baseplateComponent,
		},
	}
}

func (t *trace) addCounter(key string, delta float64) {
	t.counters[key] += delta
}

func (t *trace) setTag(key string, value interface{}) {
	t.tags[key] = fmt.Sprintf("%v", value)
}

func (t *trace) toZipkinSpan() ZipkinSpan {
	zs := ZipkinSpan{
		TraceID:  t.traceID,
		Name:     t.name,
		SpanID:   t.spanID,
		Start:    timebp.TimestampMicrosecond(t.start),
		ParentID: t.parentID,
	}
	end := t.stop
	if end.IsZero() {
		end = time.Now()
	}
	zs.Duration = timebp.DurationMicrosecond(end.Sub(t.start))

	var endpoint ZipkinEndpointInfo
	if tracer := t.internalTracer(); tracer != nil {
		endpoint = tracer.endpoint
	}

	if t.timeAnnotationReceiveKey != "" {
		zs.TimeAnnotations = append(zs.TimeAnnotations, ZipkinTimeAnnotation{
			Endpoint:  endpoint,
			Key:       t.timeAnnotationReceiveKey,
			Timestamp: timebp.TimestampMicrosecond(t.start),
		})
	}

	if t.timeAnnotationSendKey != "" {
		zs.TimeAnnotations = append(zs.TimeAnnotations, ZipkinTimeAnnotation{
			Endpoint:  endpoint,
			Key:       t.timeAnnotationSendKey,
			Timestamp: timebp.TimestampMicrosecond(end),
		})
	}

	zs.BinaryAnnotations = make([]ZipkinBinaryAnnotation, 0, len(t.counters)+len(t.tags))
	for key, value := range t.counters {
		zs.BinaryAnnotations = append(
			zs.BinaryAnnotations,
			ZipkinBinaryAnnotation{
				Endpoint: endpoint,
				Key:      counterKeyPrefix + key,
				Value:    value,
			},
		)
	}
	for key, value := range t.tags {
		zs.BinaryAnnotations = append(
			zs.BinaryAnnotations,
			ZipkinBinaryAnnotation{
				Endpoint: endpoint,
				Key:      key,
				Value:    value,
			},
		)
	}

	return zs
}

func (t *trace) isDebugSet() bool {
	return t.flags&FlagMaskDebug != 0
}

func (t *trace) setDebug(v bool) {
	if v {
		t.flags |= FlagMaskDebug
	} else {
		t.flags &= ^FlagMaskDebug
	}
}

// shouldSample returns true if this span should be sampled.
//
// If the span's debug flag was set, then this function will always return true.
func (t *trace) shouldSample() bool {
	return t.sampled || t.isDebugSet()
}

func (t *trace) publish(ctx context.Context) error {
	if !t.shouldSample() || t.tracer == nil {
		return nil
	}
	if tracer := t.internalTracer(); tracer != nil {
		return tracer.Record(ctx, t.toZipkinSpan())
	}
	return nil
}

// In opentracing spec, zero trace/span/parent ids have special meanings.
// So we should use this function to generate non-zero random ids.
func nonZeroRandUint64() uint64 {
	for {
		// NOTE: theoretically this could be an infinite loop.
		// In reality go's pseudo rand number generator won't keep giving us 0
		// uint64 so we should be fine.
		if id := randbp.R.Uint64(); id != 0 {
			return id
		}
	}
}
