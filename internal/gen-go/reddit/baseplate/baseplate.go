// Code generated by Thrift Compiler (0.21.0). DO NOT EDIT.

package baseplate

import (
	"bytes"
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"log/slog"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"
	"strings"
	"regexp"
)

// (needed to ensure safety because of naive import list construction.)
var _ = bytes.Equal
var _ = context.Background
var _ = errors.New
var _ = fmt.Printf
var _ = slog.Log
var _ = time.Now
var _ = thrift.ZERO
// (needed by validator.)
var _ = strings.Contains
var _ = regexp.MatchString

//The different types of probes supported by is_healthy endpoint.
//
//Please refer to Kubernetes' documentation for the differences between them:
//https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
//
//Your service should use Readiness probe as the fallback for unsupported probes.
//
//Note that the HTTP health check could use the string names of the probes,
//so changing the names, even without changing the numeric values,
//is considered as breaking change and should be avoided.
//
type IsHealthyProbe int64
const (
	IsHealthyProbe_READINESS IsHealthyProbe = 1
	IsHealthyProbe_LIVENESS IsHealthyProbe = 2
	IsHealthyProbe_STARTUP IsHealthyProbe = 3
)

func (p IsHealthyProbe) String() string {
	switch p {
	case IsHealthyProbe_READINESS: return "READINESS"
	case IsHealthyProbe_LIVENESS: return "LIVENESS"
	case IsHealthyProbe_STARTUP: return "STARTUP"
	}
	return "<UNSET>"
}

func IsHealthyProbeFromString(s string) (IsHealthyProbe, error) {
	switch s {
	case "READINESS": return IsHealthyProbe_READINESS, nil
	case "LIVENESS": return IsHealthyProbe_LIVENESS, nil
	case "STARTUP": return IsHealthyProbe_STARTUP, nil
	}
	return IsHealthyProbe(0), fmt.Errorf("not a valid IsHealthyProbe string")
}


func IsHealthyProbePtr(v IsHealthyProbe) *IsHealthyProbe { return &v }

func (p IsHealthyProbe) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *IsHealthyProbe) UnmarshalText(text []byte) error {
	q, err := IsHealthyProbeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *IsHealthyProbe) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = IsHealthyProbe(v)
	return nil
}

func (p *IsHealthyProbe) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

//The integer values within this enum correspond to HTTP status codes.
//
//HTTP layers can easily map errors to an appropriate status code.
type ErrorCode int64
const (
	ErrorCode_BAD_REQUEST ErrorCode = 400
	ErrorCode_UNAUTHORIZED ErrorCode = 401
	ErrorCode_PAYMENT_REQUIRED ErrorCode = 402
	ErrorCode_FORBIDDEN ErrorCode = 403
	ErrorCode_NOT_FOUND ErrorCode = 404
	ErrorCode_CONFLICT ErrorCode = 409
	ErrorCode_GONE ErrorCode = 410
	ErrorCode_PRECONDITION_FAILED ErrorCode = 412
	ErrorCode_PAYLOAD_TOO_LARGE ErrorCode = 413
	ErrorCode_IM_A_TEAPOT ErrorCode = 418
	ErrorCode_MISDIRECTED_REQUEST ErrorCode = 421
	ErrorCode_UNPROCESSABLE_ENTITY ErrorCode = 422
	ErrorCode_LOCKED ErrorCode = 423
	ErrorCode_FAILED_DEPENDENCY ErrorCode = 424
	ErrorCode_TOO_EARLY ErrorCode = 425
	ErrorCode_PRECONDITION_REQUIRED ErrorCode = 428
	ErrorCode_TOO_MANY_REQUESTS ErrorCode = 429
	ErrorCode_REQUEST_HEADER_FIELDS_TOO_LARGE ErrorCode = 431
	ErrorCode_UNAVAILABLE_FOR_LEGAL_REASONS ErrorCode = 451
	ErrorCode_INTERNAL_SERVER_ERROR ErrorCode = 500
	ErrorCode_NOT_IMPLEMENTED ErrorCode = 501
	ErrorCode_BAD_GATEWAY ErrorCode = 502
	ErrorCode_SERVICE_UNAVAILABLE ErrorCode = 503
	ErrorCode_TIMEOUT ErrorCode = 504
	ErrorCode_INSUFFICIENT_STORAGE ErrorCode = 507
	ErrorCode_LOOP_DETECTED ErrorCode = 508
	ErrorCode_USER_DEFINED ErrorCode = 1000
)

func (p ErrorCode) String() string {
	switch p {
	case ErrorCode_BAD_REQUEST: return "BAD_REQUEST"
	case ErrorCode_UNAUTHORIZED: return "UNAUTHORIZED"
	case ErrorCode_PAYMENT_REQUIRED: return "PAYMENT_REQUIRED"
	case ErrorCode_FORBIDDEN: return "FORBIDDEN"
	case ErrorCode_NOT_FOUND: return "NOT_FOUND"
	case ErrorCode_CONFLICT: return "CONFLICT"
	case ErrorCode_GONE: return "GONE"
	case ErrorCode_PRECONDITION_FAILED: return "PRECONDITION_FAILED"
	case ErrorCode_PAYLOAD_TOO_LARGE: return "PAYLOAD_TOO_LARGE"
	case ErrorCode_IM_A_TEAPOT: return "IM_A_TEAPOT"
	case ErrorCode_MISDIRECTED_REQUEST: return "MISDIRECTED_REQUEST"
	case ErrorCode_UNPROCESSABLE_ENTITY: return "UNPROCESSABLE_ENTITY"
	case ErrorCode_LOCKED: return "LOCKED"
	case ErrorCode_FAILED_DEPENDENCY: return "FAILED_DEPENDENCY"
	case ErrorCode_TOO_EARLY: return "TOO_EARLY"
	case ErrorCode_PRECONDITION_REQUIRED: return "PRECONDITION_REQUIRED"
	case ErrorCode_TOO_MANY_REQUESTS: return "TOO_MANY_REQUESTS"
	case ErrorCode_REQUEST_HEADER_FIELDS_TOO_LARGE: return "REQUEST_HEADER_FIELDS_TOO_LARGE"
	case ErrorCode_UNAVAILABLE_FOR_LEGAL_REASONS: return "UNAVAILABLE_FOR_LEGAL_REASONS"
	case ErrorCode_INTERNAL_SERVER_ERROR: return "INTERNAL_SERVER_ERROR"
	case ErrorCode_NOT_IMPLEMENTED: return "NOT_IMPLEMENTED"
	case ErrorCode_BAD_GATEWAY: return "BAD_GATEWAY"
	case ErrorCode_SERVICE_UNAVAILABLE: return "SERVICE_UNAVAILABLE"
	case ErrorCode_TIMEOUT: return "TIMEOUT"
	case ErrorCode_INSUFFICIENT_STORAGE: return "INSUFFICIENT_STORAGE"
	case ErrorCode_LOOP_DETECTED: return "LOOP_DETECTED"
	case ErrorCode_USER_DEFINED: return "USER_DEFINED"
	}
	return "<UNSET>"
}

func ErrorCodeFromString(s string) (ErrorCode, error) {
	switch s {
	case "BAD_REQUEST": return ErrorCode_BAD_REQUEST, nil
	case "UNAUTHORIZED": return ErrorCode_UNAUTHORIZED, nil
	case "PAYMENT_REQUIRED": return ErrorCode_PAYMENT_REQUIRED, nil
	case "FORBIDDEN": return ErrorCode_FORBIDDEN, nil
	case "NOT_FOUND": return ErrorCode_NOT_FOUND, nil
	case "CONFLICT": return ErrorCode_CONFLICT, nil
	case "GONE": return ErrorCode_GONE, nil
	case "PRECONDITION_FAILED": return ErrorCode_PRECONDITION_FAILED, nil
	case "PAYLOAD_TOO_LARGE": return ErrorCode_PAYLOAD_TOO_LARGE, nil
	case "IM_A_TEAPOT": return ErrorCode_IM_A_TEAPOT, nil
	case "MISDIRECTED_REQUEST": return ErrorCode_MISDIRECTED_REQUEST, nil
	case "UNPROCESSABLE_ENTITY": return ErrorCode_UNPROCESSABLE_ENTITY, nil
	case "LOCKED": return ErrorCode_LOCKED, nil
	case "FAILED_DEPENDENCY": return ErrorCode_FAILED_DEPENDENCY, nil
	case "TOO_EARLY": return ErrorCode_TOO_EARLY, nil
	case "PRECONDITION_REQUIRED": return ErrorCode_PRECONDITION_REQUIRED, nil
	case "TOO_MANY_REQUESTS": return ErrorCode_TOO_MANY_REQUESTS, nil
	case "REQUEST_HEADER_FIELDS_TOO_LARGE": return ErrorCode_REQUEST_HEADER_FIELDS_TOO_LARGE, nil
	case "UNAVAILABLE_FOR_LEGAL_REASONS": return ErrorCode_UNAVAILABLE_FOR_LEGAL_REASONS, nil
	case "INTERNAL_SERVER_ERROR": return ErrorCode_INTERNAL_SERVER_ERROR, nil
	case "NOT_IMPLEMENTED": return ErrorCode_NOT_IMPLEMENTED, nil
	case "BAD_GATEWAY": return ErrorCode_BAD_GATEWAY, nil
	case "SERVICE_UNAVAILABLE": return ErrorCode_SERVICE_UNAVAILABLE, nil
	case "TIMEOUT": return ErrorCode_TIMEOUT, nil
	case "INSUFFICIENT_STORAGE": return ErrorCode_INSUFFICIENT_STORAGE, nil
	case "LOOP_DETECTED": return ErrorCode_LOOP_DETECTED, nil
	case "USER_DEFINED": return ErrorCode_USER_DEFINED, nil
	}
	return ErrorCode(0), fmt.Errorf("not a valid ErrorCode string")
}


func ErrorCodePtr(v ErrorCode) *ErrorCode { return &v }

func (p ErrorCode) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *ErrorCode) UnmarshalText(text []byte) error {
	q, err := ErrorCodeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *ErrorCode) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = ErrorCode(v)
	return nil
}

func (p *ErrorCode) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

//An integer measuring the number of milliseconds of UTC time since epoch.
//
type TimestampMilliseconds int64

func TimestampMillisecondsPtr(v TimestampMilliseconds) *TimestampMilliseconds { return &v }

// The arg struct for is_healthy endpoint.
// 
// 
// Attributes:
//  - Probe
// 
type IsHealthyRequest struct {
	Probe *IsHealthyProbe `thrift:"probe,1" db:"probe" json:"probe,omitempty"`
}

func NewIsHealthyRequest() *IsHealthyRequest {
	return &IsHealthyRequest{}
}

var IsHealthyRequest_Probe_DEFAULT IsHealthyProbe

func (p *IsHealthyRequest) GetProbe() IsHealthyProbe {
	if !p.IsSetProbe() {
		return IsHealthyRequest_Probe_DEFAULT
	}
	return *p.Probe
}

func (p *IsHealthyRequest) IsSetProbe() bool {
	return p.Probe != nil
}

func (p *IsHealthyRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *IsHealthyRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := IsHealthyProbe(v)
		p.Probe = &temp
	}
	return nil
}

func (p *IsHealthyRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "IsHealthyRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *IsHealthyRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetProbe() {
		if err := oprot.WriteFieldBegin(ctx, "probe", thrift.I32, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:probe: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.Probe)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.probe (1) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:probe: ", p), err)
		}
	}
	return err
}

func (p *IsHealthyRequest) Equals(other *IsHealthyRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Probe != other.Probe {
		if p.Probe == nil || other.Probe == nil {
			return false
		}
		if (*p.Probe) != (*other.Probe) { return false }
	}
	return true
}

func (p *IsHealthyRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IsHealthyRequest(%+v)", *p)
}

func (p *IsHealthyRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*baseplate.IsHealthyRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*IsHealthyRequest)(nil)

func (p *IsHealthyRequest) Validate() error {
	return nil
}

// Attributes:
//  - Code: A code describing the general nature of the error.
// This should be specified for all errors. This field uses
// the i32 type instead of the ErrorCode type in order to give
// developers an escape hatch to define their own error codes.
// Developers should do their best to avoid defining a custom
// error code. Developers should use a value higher than 1000
// when defining custom codes.
//  - Message: A human-readable error message. It should both explain the error
// and offer an actionable resolution to it, if applicable. It should
// be safe to desplay this message in a user-facing client.
//  - Details: A map of additional error information. This is most useful
// when there is a validation error. The server may use this map
// to return multiple errors. This should be safe for clients to
// display. Example:
//     {
//         "post.title": "This field is too long.",
//         "post.kind": "This field is required."
//     }
//  - Retryable: Server could choose to set this field to true to explicitly indicate
// that client shall retry this request, and false to explicitly indicate that
// client shall not retry this request. Unset means that it's up to the client
// to decide (using other information, for example the code) whether to retry
// this request.
// 
type Error struct {
	Code *int32 `thrift:"code,1" db:"code" json:"code,omitempty"`
	Message *string `thrift:"message,2" db:"message" json:"message,omitempty"`
	Details map[string]string `thrift:"details,3" db:"details" json:"details,omitempty"`
	Retryable *bool `thrift:"retryable,4" db:"retryable" json:"retryable,omitempty"`
}

func NewError() *Error {
	return &Error{}
}

var Error_Code_DEFAULT int32

func (p *Error) GetCode() int32 {
	if !p.IsSetCode() {
		return Error_Code_DEFAULT
	}
	return *p.Code
}

var Error_Message_DEFAULT string

func (p *Error) GetMessage() string {
	if !p.IsSetMessage() {
		return Error_Message_DEFAULT
	}
	return *p.Message
}

var Error_Details_DEFAULT map[string]string


func (p *Error) GetDetails() map[string]string {
	return p.Details
}

var Error_Retryable_DEFAULT bool

func (p *Error) GetRetryable() bool {
	if !p.IsSetRetryable() {
		return Error_Retryable_DEFAULT
	}
	return *p.Retryable
}

func (p *Error) IsSetCode() bool {
	return p.Code != nil
}

func (p *Error) IsSetMessage() bool {
	return p.Message != nil
}

func (p *Error) IsSetDetails() bool {
	return p.Details != nil
}

func (p *Error) IsSetRetryable() bool {
	return p.Retryable != nil
}

func (p *Error) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Error) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Code = &v
	}
	return nil
}

func (p *Error) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Message = &v
	}
	return nil
}

func (p *Error) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string]string, size)
	p.Details = tMap
	for i := 0; i < size; i++ {
		var _key0 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key0 = v
		}
		var _val1 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val1 = v
		}
		p.Details[_key0] = _val1
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *Error) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Retryable = &v
	}
	return nil
}

func (p *Error) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Error"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Error) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetCode() {
		if err := oprot.WriteFieldBegin(ctx, "code", thrift.I32, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.Code)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.code (1) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err)
		}
	}
	return err
}

func (p *Error) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetMessage() {
		if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:message: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.Message)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.message (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:message: ", p), err)
		}
	}
	return err
}

func (p *Error) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDetails() {
		if err := oprot.WriteFieldBegin(ctx, "details", thrift.MAP, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:details: ", p), err)
		}
		if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Details)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.Details {
			if err := oprot.WriteString(ctx, string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteString(ctx, string(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(ctx); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:details: ", p), err)
		}
	}
	return err
}

func (p *Error) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRetryable() {
		if err := oprot.WriteFieldBegin(ctx, "retryable", thrift.BOOL, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:retryable: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Retryable)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.retryable (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:retryable: ", p), err)
		}
	}
	return err
}

func (p *Error) Equals(other *Error) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Code != other.Code {
		if p.Code == nil || other.Code == nil {
			return false
		}
		if (*p.Code) != (*other.Code) { return false }
	}
	if p.Message != other.Message {
		if p.Message == nil || other.Message == nil {
			return false
		}
		if (*p.Message) != (*other.Message) { return false }
	}
	if len(p.Details) != len(other.Details) { return false }
	for k, _tgt := range p.Details {
		_src2 := other.Details[k]
		if _tgt != _src2 { return false }
	}
	if p.Retryable != other.Retryable {
		if p.Retryable == nil || other.Retryable == nil {
			return false
		}
		if (*p.Retryable) != (*other.Retryable) { return false }
	}
	return true
}

func (p *Error) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Error(%+v)", *p)
}

func (p *Error) Error() string {
	return p.String()
}

func (Error) TExceptionType() thrift.TExceptionType {
	return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*Error)(nil)

func (p *Error) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*baseplate.Error",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Error)(nil)

func (p *Error) Validate() error {
	return nil
}

type BaseplateService interface {	//The base for any baseplate-based service.
	//
	//Your service should inherit from this one so that common tools can interact
	//with any expected interfaces.
	//
	//DEPRECATED: Please migrate to BaseplateServiceV2.
	//

	// Return whether or not the service is healthy.
	// 
	// The healthchecker (baseplate.server.healthcheck) expects this endpoint to
	// exist so it can determine your service's health.
	// 
	// This should return True if the service is healthy. If the service is
	// unhealthy, it can return False or raise an exception.
	// 
	IsHealthy(ctx context.Context) (_r bool, _err error)
}

//The base for any baseplate-based service.
//
//Your service should inherit from this one so that common tools can interact
//with any expected interfaces.
//
//DEPRECATED: Please migrate to BaseplateServiceV2.
//
type BaseplateServiceClient struct {
	c thrift.TClient
	meta thrift.ResponseMeta
}

func NewBaseplateServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *BaseplateServiceClient {
	return &BaseplateServiceClient{
		c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
	}
}

func NewBaseplateServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *BaseplateServiceClient {
	return &BaseplateServiceClient{
		c: thrift.NewTStandardClient(iprot, oprot),
	}
}

func NewBaseplateServiceClient(c thrift.TClient) *BaseplateServiceClient {
	return &BaseplateServiceClient{
		c: c,
	}
}

func (p *BaseplateServiceClient) Client_() thrift.TClient {
	return p.c
}

func (p *BaseplateServiceClient) LastResponseMeta_() thrift.ResponseMeta {
	return p.meta
}

func (p *BaseplateServiceClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
	p.meta = meta
}

// Return whether or not the service is healthy.
// 
// The healthchecker (baseplate.server.healthcheck) expects this endpoint to
// exist so it can determine your service's health.
// 
// This should return True if the service is healthy. If the service is
// unhealthy, it can return False or raise an exception.
// 
func (p *BaseplateServiceClient) IsHealthy(ctx context.Context) (_r bool, _err error) {
	var _args3 BaseplateServiceIsHealthyArgs
	var _result5 BaseplateServiceIsHealthyResult
	var _meta4 thrift.ResponseMeta
	_meta4, _err = p.Client_().Call(ctx, "is_healthy", &_args3, &_result5)
	p.SetLastResponseMeta_(_meta4)
	if _err != nil {
		return
	}
	return _result5.GetSuccess(), nil
}

type BaseplateServiceProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler BaseplateService
}

func (p *BaseplateServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *BaseplateServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *BaseplateServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewBaseplateServiceProcessor(handler BaseplateService) *BaseplateServiceProcessor {

	self6 := &BaseplateServiceProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
	self6.processorMap["is_healthy"] = &baseplateServiceProcessorIsHealthy{handler:handler}
	return self6
}

func (p *BaseplateServiceProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
	if err2 != nil { return false, thrift.WrapTException(err2) }
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(ctx, seqId, iprot, oprot)
	}
	iprot.Skip(ctx, thrift.STRUCT)
	iprot.ReadMessageEnd(ctx)
	x7 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
	oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
	x7.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return false, x7
}

type baseplateServiceProcessorIsHealthy struct {
	handler BaseplateService
}

func (p *baseplateServiceProcessorIsHealthy) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err8 error
	args := BaseplateServiceIsHealthyArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "is_healthy", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := BaseplateServiceIsHealthyResult{}
	if retval, err2 := p.handler.IsHealthy(ctx); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		if errors.Is(err2, thrift.ErrAbandonRequest) {
			return false, thrift.WrapTException(err2)
		}
		if errors.Is(err2, context.Canceled) {
			if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err)
			}
		}
		_exc9 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing is_healthy: " + err2.Error())
		if err2 := oprot.WriteMessageBegin(ctx, "is_healthy", thrift.EXCEPTION, seqId); err2 != nil {
			_write_err8 = thrift.WrapTException(err2)
		}
		if err2 := _exc9.Write(ctx, oprot); _write_err8 == nil && err2 != nil {
			_write_err8 = thrift.WrapTException(err2)
		}
		if err2 := oprot.WriteMessageEnd(ctx); _write_err8 == nil && err2 != nil {
			_write_err8 = thrift.WrapTException(err2)
		}
		if err2 := oprot.Flush(ctx); _write_err8 == nil && err2 != nil {
			_write_err8 = thrift.WrapTException(err2)
		}
		if _write_err8 != nil {
			return false, thrift.WrapTException(_write_err8)
		}
		return true, err
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "is_healthy", thrift.REPLY, seqId); err2 != nil {
		_write_err8 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err8 == nil && err2 != nil {
		_write_err8 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err8 == nil && err2 != nil {
		_write_err8 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err8 == nil && err2 != nil {
		_write_err8 = thrift.WrapTException(err2)
	}
	if _write_err8 != nil {
		return false, thrift.WrapTException(_write_err8)
	}
	return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

type BaseplateServiceIsHealthyArgs struct {
}

func NewBaseplateServiceIsHealthyArgs() *BaseplateServiceIsHealthyArgs {
	return &BaseplateServiceIsHealthyArgs{}
}

func (p *BaseplateServiceIsHealthyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *BaseplateServiceIsHealthyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "is_healthy_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *BaseplateServiceIsHealthyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BaseplateServiceIsHealthyArgs(%+v)", *p)
}

func (p *BaseplateServiceIsHealthyArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*baseplate.BaseplateServiceIsHealthyArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*BaseplateServiceIsHealthyArgs)(nil)

// Attributes:
//  - Success
// 
type BaseplateServiceIsHealthyResult struct {
	Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewBaseplateServiceIsHealthyResult() *BaseplateServiceIsHealthyResult {
	return &BaseplateServiceIsHealthyResult{}
}

var BaseplateServiceIsHealthyResult_Success_DEFAULT bool

func (p *BaseplateServiceIsHealthyResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return BaseplateServiceIsHealthyResult_Success_DEFAULT
	}
	return *p.Success
}

func (p *BaseplateServiceIsHealthyResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *BaseplateServiceIsHealthyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *BaseplateServiceIsHealthyResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *BaseplateServiceIsHealthyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "is_healthy_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *BaseplateServiceIsHealthyResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *BaseplateServiceIsHealthyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BaseplateServiceIsHealthyResult(%+v)", *p)
}

func (p *BaseplateServiceIsHealthyResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*baseplate.BaseplateServiceIsHealthyResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*BaseplateServiceIsHealthyResult)(nil)


type BaseplateServiceV2 interface {	//The base for any baseplate-based service.
	//
	//Your service should inherit from this one so that common tools can interact
	//with any expected interfaces.
	//

	// Return whether or not the service is healthy.
	// 
	// The healthchecker (baseplate.server.healthcheck) expects this endpoint to
	// exist so it can determine your service's health.
	// 
	// This should return True if the service is healthy. If the service is
	// unhealthy, it can return False or raise an exception.
	// 
	// 
	// Parameters:
	//  - Request
	// 
	IsHealthy(ctx context.Context, request *IsHealthyRequest) (_r bool, _err error)
}

//The base for any baseplate-based service.
//
//Your service should inherit from this one so that common tools can interact
//with any expected interfaces.
//
type BaseplateServiceV2Client struct {
	c thrift.TClient
	meta thrift.ResponseMeta
}

func NewBaseplateServiceV2ClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *BaseplateServiceV2Client {
	return &BaseplateServiceV2Client{
		c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
	}
}

func NewBaseplateServiceV2ClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *BaseplateServiceV2Client {
	return &BaseplateServiceV2Client{
		c: thrift.NewTStandardClient(iprot, oprot),
	}
}

func NewBaseplateServiceV2Client(c thrift.TClient) *BaseplateServiceV2Client {
	return &BaseplateServiceV2Client{
		c: c,
	}
}

func (p *BaseplateServiceV2Client) Client_() thrift.TClient {
	return p.c
}

func (p *BaseplateServiceV2Client) LastResponseMeta_() thrift.ResponseMeta {
	return p.meta
}

func (p *BaseplateServiceV2Client) SetLastResponseMeta_(meta thrift.ResponseMeta) {
	p.meta = meta
}

// Return whether or not the service is healthy.
// 
// The healthchecker (baseplate.server.healthcheck) expects this endpoint to
// exist so it can determine your service's health.
// 
// This should return True if the service is healthy. If the service is
// unhealthy, it can return False or raise an exception.
// 
// 
// Parameters:
//  - Request
// 
func (p *BaseplateServiceV2Client) IsHealthy(ctx context.Context, request *IsHealthyRequest) (_r bool, _err error) {
	var _args10 BaseplateServiceV2IsHealthyArgs
	_args10.Request = request
	var _result12 BaseplateServiceV2IsHealthyResult
	var _meta11 thrift.ResponseMeta
	_meta11, _err = p.Client_().Call(ctx, "is_healthy", &_args10, &_result12)
	p.SetLastResponseMeta_(_meta11)
	if _err != nil {
		return
	}
	return _result12.GetSuccess(), nil
}

type BaseplateServiceV2Processor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler BaseplateServiceV2
}

func (p *BaseplateServiceV2Processor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *BaseplateServiceV2Processor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *BaseplateServiceV2Processor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewBaseplateServiceV2Processor(handler BaseplateServiceV2) *BaseplateServiceV2Processor {

	self13 := &BaseplateServiceV2Processor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
	self13.processorMap["is_healthy"] = &baseplateServiceV2ProcessorIsHealthy{handler:handler}
	return self13
}

func (p *BaseplateServiceV2Processor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
	if err2 != nil { return false, thrift.WrapTException(err2) }
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(ctx, seqId, iprot, oprot)
	}
	iprot.Skip(ctx, thrift.STRUCT)
	iprot.ReadMessageEnd(ctx)
	x14 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
	oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
	x14.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return false, x14
}

type baseplateServiceV2ProcessorIsHealthy struct {
	handler BaseplateServiceV2
}

func (p *baseplateServiceV2ProcessorIsHealthy) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err15 error
	args := BaseplateServiceV2IsHealthyArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "is_healthy", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := BaseplateServiceV2IsHealthyResult{}
	if retval, err2 := p.handler.IsHealthy(ctx, args.Request); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		if errors.Is(err2, thrift.ErrAbandonRequest) {
			return false, thrift.WrapTException(err2)
		}
		if errors.Is(err2, context.Canceled) {
			if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err)
			}
		}
		_exc16 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing is_healthy: " + err2.Error())
		if err2 := oprot.WriteMessageBegin(ctx, "is_healthy", thrift.EXCEPTION, seqId); err2 != nil {
			_write_err15 = thrift.WrapTException(err2)
		}
		if err2 := _exc16.Write(ctx, oprot); _write_err15 == nil && err2 != nil {
			_write_err15 = thrift.WrapTException(err2)
		}
		if err2 := oprot.WriteMessageEnd(ctx); _write_err15 == nil && err2 != nil {
			_write_err15 = thrift.WrapTException(err2)
		}
		if err2 := oprot.Flush(ctx); _write_err15 == nil && err2 != nil {
			_write_err15 = thrift.WrapTException(err2)
		}
		if _write_err15 != nil {
			return false, thrift.WrapTException(_write_err15)
		}
		return true, err
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "is_healthy", thrift.REPLY, seqId); err2 != nil {
		_write_err15 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err15 == nil && err2 != nil {
		_write_err15 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err15 == nil && err2 != nil {
		_write_err15 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err15 == nil && err2 != nil {
		_write_err15 = thrift.WrapTException(err2)
	}
	if _write_err15 != nil {
		return false, thrift.WrapTException(_write_err15)
	}
	return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Request
// 
type BaseplateServiceV2IsHealthyArgs struct {
	Request *IsHealthyRequest `thrift:"request,1" db:"request" json:"request"`
}

func NewBaseplateServiceV2IsHealthyArgs() *BaseplateServiceV2IsHealthyArgs {
	return &BaseplateServiceV2IsHealthyArgs{}
}

var BaseplateServiceV2IsHealthyArgs_Request_DEFAULT *IsHealthyRequest

func (p *BaseplateServiceV2IsHealthyArgs) GetRequest() *IsHealthyRequest {
	if !p.IsSetRequest() {
		return BaseplateServiceV2IsHealthyArgs_Request_DEFAULT
	}
	return p.Request
}

func (p *BaseplateServiceV2IsHealthyArgs) IsSetRequest() bool {
	return p.Request != nil
}

func (p *BaseplateServiceV2IsHealthyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *BaseplateServiceV2IsHealthyArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Request = &IsHealthyRequest{}
	if err := p.Request.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Request), err)
	}
	return nil
}

func (p *BaseplateServiceV2IsHealthyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "is_healthy_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *BaseplateServiceV2IsHealthyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "request", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:request: ", p), err)
	}
	if err := p.Request.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Request), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:request: ", p), err)
	}
	return err
}

func (p *BaseplateServiceV2IsHealthyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BaseplateServiceV2IsHealthyArgs(%+v)", *p)
}

func (p *BaseplateServiceV2IsHealthyArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*baseplate.BaseplateServiceV2IsHealthyArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*BaseplateServiceV2IsHealthyArgs)(nil)

// Attributes:
//  - Success
// 
type BaseplateServiceV2IsHealthyResult struct {
	Success *bool `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewBaseplateServiceV2IsHealthyResult() *BaseplateServiceV2IsHealthyResult {
	return &BaseplateServiceV2IsHealthyResult{}
}

var BaseplateServiceV2IsHealthyResult_Success_DEFAULT bool

func (p *BaseplateServiceV2IsHealthyResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return BaseplateServiceV2IsHealthyResult_Success_DEFAULT
	}
	return *p.Success
}

func (p *BaseplateServiceV2IsHealthyResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *BaseplateServiceV2IsHealthyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *BaseplateServiceV2IsHealthyResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *BaseplateServiceV2IsHealthyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "is_healthy_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *BaseplateServiceV2IsHealthyResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *BaseplateServiceV2IsHealthyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BaseplateServiceV2IsHealthyResult(%+v)", *p)
}

func (p *BaseplateServiceV2IsHealthyResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*baseplate.BaseplateServiceV2IsHealthyResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*BaseplateServiceV2IsHealthyResult)(nil)


